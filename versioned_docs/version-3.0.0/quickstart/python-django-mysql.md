---
id: samples-django-mysql
title: Employee Data CRUD App
sidebar_label: Django + mysql
description: The following sample app showcases how to use the Django framework and the Keploy Platform.
tags:
  - python
  - quickstart
  - samples
  - examples
  - django
  - tutorial
  - python-framework
  - mysql
keyword:
  - Django Framework
  - mysql
  - SQL
  - Python
  - API Test generator
  - django
  - Auto case generation
---

## Introduction

This application is a simple Employee Management System built with Django and MySQL. It allows you to create, retrieve, update, and delete employee records via RESTful API endpoints. The application is containerized using Docker, making it easy to deploy and run in different environments. The backend is powered by Django, and the MySQL database is used to store employee information.

import InstallationGuide from '../concepts/installation.md'

<InstallationGuide/>

# Get Started! ðŸŽ¬

## Clone the app ðŸ§ª

```bash
git clone https://github.com/keploy/samples-python.git && cd samples-python/django-mysql
```

Open a different terminal and setup your Mysql through docker

```shell
docker run --name mySQL --network keploy-network -e MYSQL_ROOT_PASSWORD=keploy -e MYSQL_DATABASE=keploy_db -e MYSQL_USER=admin -e MYSQL_PASSWORD=keploy -p 3306:3306 -d mysql

```

Build and Run Django Application Container

```shell
docker build --build-arg HOST_PWD="$(pwd)" -t py-app .

```

## Lights, Camera, Record! ðŸŽ¥

Capture the test-cases-

```shell
keploy record -c "sudo docker run --name django-app --net keploy-network -p 8000:8000 -v $(pwd):$(pwd) --rm py-app"
```

You should be able to see this in your terminal

<img src="https://keploy-devrel.s3.us-west-2.amazonaws.com/keploy-record-django-mysql.webp" alt="Sample Keploy record django-mysql" width="100%" style={{ borderRadius: '5px' }} />

ðŸ”¥**Make some API calls**.

Let's make URLs short and sweet:

## Generate testcases

To generate testcases we just need to **make some API calls.**

1. **Make a POST request:**

```bash

  curl -X POST http://localhost:8000/api/employee/create/ -H "Content-Type: application/json" -d '{"name": "John Doe", "years_of_experience": 5, "field": "Computer Science", "company": "TechCorp"}'

```

2. **Make a GET request:**

```bash

curl -X GET http://localhost:8000/api/employee/

```

3. **Make a PUT request:**

```bash

 curl -X PUT http://localhost:8000/api/employee/update/1/ -H "Content-Type: application/json" -d '{"name": "Jane Doe", "years_of_experience": 6, "field": "Data Science", "company": "TechCorp"}'

```

4. **Make a DELETE request:**

```bash
curl -X DELETE http://localhost:8000/api/employee/delete/1/
```

And once you are done, you can stop the recording and give yourself a pat on the back! With that simple spell, you've conjured up a test case with a mock! Explore the **keploy** directory and you'll discover your handiwork in `tests` directory and `mocks.yml`.

This is an example of what your mocks would look like

```yaml
# Generated by Keploy (2.6.22)
version: api.keploy.io/v1beta1
kind: MySQL
name: mock-0
spec:
  metadata:
    connID: "0"
    requestOperation: HandshakeV10
    responseOperation: OK
    type: config
  requests:
    - header:
        header:
          payload_length: 205
          sequence_id: 1
        packet_type: HandshakeResponse41
      message:
        capability_flags: 12558991
        max_packet_size: 1073741824
        character_set: 33
        filler:
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        username: admin
        auth_response:
          [
            192,
            100,
            88,
            71,
            91,
            252,
            72,
            166,
            159,
            206,
            23,
            237,
            148,
            243,
            163,
            6,
            88,
            23,
            166,
            84,
            221,
            255,
            84,
            159,
            200,
            159,
            6,
            122,
            117,
            240,
            47,
            166,
          ]
        database: keploy_db
        auth_plugin_name: caching_sha2_password
        connection_attributes:
          _client_name: libmariadb
          _client_version: 3.3.14
          _os: Linux
          _pid: "7"
          _platform: aarch64
          _server_host: mySQL
        zstdcompressionlevel: 0
  responses:
    - header:
        header:
          payload_length: 73
          sequence_id: 0
        packet_type: HandshakeV10
      message:
        protocol_version: 10
        server_version: 9.4.0
        connection_id: 54
        auth_plugin_data:
          [
            113,
            21,
            7,
            81,
            7,
            12,
            87,
            112,
            51,
            94,
            104,
            13,
            51,
            38,
            48,
            123,
            104,
            89,
            77,
            39,
            0,
          ]
        filler: 0
        capability_flags: 3758096383
        character_set: 255
        status_flags: 2
        auth_plugin_name: caching_sha2_password
    - header:
        header:
          payload_length: 2
          sequence_id: 2
        packet_type: AuthMoreData
      message:
        status_tag: 1
        data: FastAuthSuccess
    - header:
        header:
          payload_length: 21
          sequence_id: 3
        packet_type: OK
      message:
        header: 0
        affected_rows: 0
        last_insert_id: 0
        status_flags: 16386
        warnings: 0
        info: "\0\f\x01\n\tkeploy_db"
  created: 1753793504
  reqtimestampmock: 2025-07-29T12:51:44.329059627Z
  restimestampmock: 2025-07-29T12:51:44.330062582Z
```

## **Time to put things to the test ðŸ§ª:**

Note:
If you want to view the coverage, follow the guide below:

There is an alternate entrypoint in the Dockerfile that is currently commented out. To enable it, simply uncomment the entrypoint, rebuild the Docker image, and run the application again with Keploy.

```bash
keploy test -c "sudo docker run --name django-app --net keploy-network -p 8000:8000 -v $(pwd):$(pwd) --rm py-app"
```

This is how your terminal would look like :

<img src="https://keploy-devrel.s3.us-west-2.amazonaws.com/keploy-test-django-mysql.webp" alt="Sample Keploy Test django-mysql" width="100%" style={{ borderRadius: '5px' }} />

Once the tests are executed, a .coverage file will be generated. To view the coverage report, run:

```bash
python3 -m coverage report
```

This is how output would look like :

<img src="https://keploy-devrel.s3.us-west-2.amazonaws.com/keploy-test-coverage-django-mysql.webp" alt="Sample Keploy Test django-mysql" width="100%" style={{ borderRadius: '5px' }} />

You can experiment with different API calls, modify the database response in mocks.yml, or adjust the request or response in test-x.yml. Then, run the tests again to see the change in response
